#pragma once

#include <stdint.h>
#include "util/dynarr.h"
#include "error.h"

#define TRUE 1
#define FALSE 0

// Used for the lexer. Gets the next character in the source and throws and error if there
// isn't one
#define GET_NEXT_CHAR(current_char) if(*++current_char == 0x00) { throw_compiler_error("Did not expect end of file!!"); }
#define IS_WHITESPACE(c) c == ' ' || c == '\t'
#define IS_NUMBER(c) c >= '0' && c <= '9' // Check if character c is in number ascii range
#define IS_LETTER(c) (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')

// Keywords that are reserved for use
// TODO : Make this definition atuomatic
#define COMPILER_RESERVE_KEYWORD_COUNT 1
const static char* compiler_reserved_keywords[] = {
    "function",
};


typedef enum lexer_token_type_e {
    YET_UNKOWN, // Catch all for a symbol, number, keyword, or special character. Will be determined after gathering entire token value
    SYMBOL,
    KEYWORD,
    STRING,
    NUMBER,

    SCOPE_START,
    SCOPE_END,
    ADD,
    SUBTRACT,
    EQUALS,

    ENDL,
    NONE,
} lexer_token_type_e;
typedef struct lexer_token_t {
    lexer_token_type_e type;
    char value[100];
} lexer_token_t;
void lexer_token_initialize(lexer_token_t* token);

// Special non-ascii characters the lexer will insert as SPECIAL tokens
typedef struct special_char_t {
    char character;
    lexer_token_type_e token;
} special_char_t;

#define COMPILER_SPECIAL_CHARS_COUNT 5
const static special_char_t compiler_special_chars[] = {
    { '{', SCOPE_START },
    { '}', SCOPE_END },
    { '+', ADD },
    { '-', SUBTRACT },
    { '=', EQUALS },
};
typedef struct lexer_state_t { 
    lexer_token_type_e currently_reading;
} lexer_state_t;
void lexer_state_initialize(lexer_state_t* compile_state);

// UNIMPLEMENTED
/* Takes in a file, and compiles it by converting it to a const char* and passing to
 * compile
 */
int compile_file(const char* filepath);

/* Takes in a dynamic array of tokens generated by lex, and compiles them
 * you probably want to use compile() or compile_file() */
int compile_tokens(dyn_arr_t tokens);

/* Takes in a program, and outputs a lex'd dynamic array containing lexer_token_t that
 * compile_tokens can use to output a compiled file */
dyn_arr_t lex(char* filesrc);

/* Takes in the source code of a prgram, and both lexes and compiles it */
int compile(char* filesrc);
